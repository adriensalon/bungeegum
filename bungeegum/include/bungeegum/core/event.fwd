#pragma once

#include <functional>
#include <future>
#include <optional>
#include <typeindex>
#include <unordered_map>
#include <vector>

#include <bungeegum/glue/map.fwd>
#include <bungeegum/glue/raw.fwd>
#include <bungeegum/glue/registry.fwd>
#include <bungeegum/glue/typelist.fwd>

namespace bungeegum {

template <typename... values_t>
struct event;

namespace detail {

    template <typename... values_t>
    struct typed_event_data {
        std::uintptr_t raw_event = 0u;
        std::vector<std::function<void(values_t...)>> callbacks = {};
        std::vector<std::future<future_typelist_t<values_t...>>> futures = {};
        std::vector<std::shared_future<future_typelist_t<values_t...>>> shared_futures = {};

        typed_event_data() = default;
        typed_event_data(const typed_event_data& other);
        typed_event_data& operator=(const typed_event_data& other);
        typed_event_data(typed_event_data&& other) = default;
        typed_event_data& operator=(typed_event_data&& other) = default;
        ~typed_event_data();
    };

    struct untyped_event_data {
        std::vector<std::type_index> kinds = {};
        std::function<void()> ticker = nullptr;
    };

    struct events_registry {
        registry events = {};
        std::unordered_map<std::uintptr_t, entity_t> possessed = {};
        std::unordered_map<std::uintptr_t, std::reference_wrapper<untyped_event_data>> registered = {};

        template <typename... values_t>
        typed_event_data<values_t...>& get_typed(event<values_t...>& event_object);
    };

    inline events_registry events_context;
}
}
