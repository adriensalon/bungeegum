#pragma once

#include <chrono>

#include <bungeegum/core/event.hpp>
#include <bungeegum/glue/curve.hpp>
#include <bungeegum/glue/lerp.fwd>

namespace bungeegum {

template <typename value_t>
struct animation;

namespace detail {

    template <typename value_t>
    struct typed_animation_data {
        std::uintptr_t raw_animation = 0u;
        std::unique_ptr<value_t> min_value = nullptr;
        std::unique_ptr<value_t> max_value = nullptr;
        typed_event_data<value_t> event;
        curve eval_curve { 0.f, 1.f, std::vector<float2> {}, false };
        float duration_seconds = 0.f;
        bool is_playing = false;
        float playing_cursor_seconds = 0.f;

        typed_animation_data() = default;
        typed_animation_data(const typed_animation_data& other) = default;
        typed_animation_data& operator=(const typed_animation_data& other) = default;
        typed_animation_data(typed_animation_data&& other) = default;
        typed_animation_data& operator=(typed_animation_data&& other) = default;
        ~typed_animation_data();
    };

    struct untyped_animation_data {
        std::unique_ptr<std::type_index> kind = nullptr;
        std::function<void(const std::chrono::milliseconds&)> ticker = nullptr;
        //
        std::array<float, 100> overlay_samples { 0.f };
        std::array<float, 2> overlay_position { 0.f };
    };

    struct animations_registry {
        registry animations = {};
        std::unordered_map<std::uintptr_t, entity_t> possessed = {};
        std::unordered_map<std::uintptr_t, std::reference_wrapper<untyped_animation_data>> registered = {};

        template <typename value_t>
        typed_animation_data<value_t>& get_typed(animation<value_t>& animation_object);

        //
        //
        //
        //

        // void tick(const std::chrono::milliseconds& delta_time);
        // void iterate(const std::function<void(untyped_animation_data&)>& iterate_callback);

        // template <typename value_t>
        // typed_animation_data<value_t>& create(events_registry& events);

        // template <typename value_t>
        // untyped_animation_data& get(typed_animation_data<value_t>& widget);

        // template <typename value_t>
        // typed_animation_data<value_t>& get(untyped_animation_data& data);

        // template <typename value_t>
        // void iterate(const std::function<void(typed_animation_data<value_t>&)>& iterate_callback);
    };

    inline animations_registry animations_context;

}
}
