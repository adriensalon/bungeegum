#pragma once

#include <chrono>
#include <functional>
#include <optional>
#include <typeindex>
#include <vector>

#include <bungeegum/core/event.hpp>
#include <bungeegum/glue/curve.hpp>
#include <bungeegum/glue/lerp.fwd>

namespace bungeegum {
namespace detail {

    template <typename value_t>
    struct typed_animation_data {
        std::unique_ptr<value_t> min_value = nullptr;
        std::unique_ptr<value_t> max_value = nullptr;
        typed_event_data<value_t> event;
        float playing_cursor_seconds = 0.f;
        float duration_seconds = 0.f;
    };

    struct untyped_animation_data {
        std::unique_ptr<std::type_index> kind;
        std::function<void(const std::chrono::milliseconds&)> tick = nullptr;
        bool is_playing = false;
        curve eval_curve { 0.f, 1.f, std::vector<float2> {}, false };
        float2 eval_point { 0.f, 0.f };
    };

    struct animations_registry {
        registry animations;

        void tick(const std::chrono::milliseconds& delta_time);
        void iterate(const std::function<void(untyped_animation_data&)>& iterate_callback);

        template <typename value_t>
        typed_animation_data<value_t>& create(events_registry& events);

        template <typename value_t>
        void destroy(const typed_animation_data<value_t>& animation);

        template <typename value_t>
        void start(typed_animation_data<value_t>& animation);

        template <typename value_t>
        void stop(typed_animation_data<value_t>& animation);

        template <typename value_t>
        void reset(typed_animation_data<value_t>& animation);

        template <typename value_t>
        void shape(typed_animation_data<value_t>& animation, const curve& animation_curve);

        template <typename value_t>
        void set_animation_min(typed_animation_data<value_t>& animation, value_t&& min_value);

        template <typename value_t>
        void set_animation_max(typed_animation_data<value_t>& animation, value_t&& max_value);

        template <typename value_t, typename duration_unit_t = std::chrono::seconds>
        void set_animation_duration(typed_animation_data<value_t>& animation, const unsigned int count);

        template <typename value_t>
        void attach_animation(typed_animation_data<value_t>& animation);

        template <typename value_t>
        void detach_animation(typed_animation_data<value_t>& animation);

        template <typename value_t>
        untyped_animation_data& get(typed_animation_data<value_t>& widget);

        template <typename value_t>
        typed_animation_data<value_t>& get(untyped_animation_data& data);

        template <typename value_t>
        void iterate(const std::function<void(typed_animation_data<value_t>&)>& iterate_callback);
    };

    inline animations_registry animations_context;

}
}
