#pragma once

#include <chrono>

#include <bungeegum/core/event.hpp>
#include <bungeegum/glue/curve.hpp>
#include <bungeegum/glue/lerp.fwd>

namespace bungeegum {

template <typename value_t>
struct animation;

namespace detail {

    template <typename value_t>
    struct typed_animation_data {
        std::uintptr_t raw_animation = 0u;
        std::unique_ptr<value_t> min_value = nullptr;
        std::unique_ptr<value_t> max_value = nullptr;
        typed_event_data<value_t> event;
        curve eval_curve { 0.f, 1.f, std::vector<float2> {}, false };
        float duration_seconds = 0.f;
        bool is_playing = false;
        float playing_cursor_seconds = 0.f;

        typed_animation_data() = default;
        typed_animation_data(const typed_animation_data& other) = default;
        typed_animation_data& operator=(const typed_animation_data& other) = default;
        typed_animation_data(typed_animation_data&& other) = default;
        typed_animation_data& operator=(typed_animation_data&& other) = default;
        ~typed_animation_data();
    };

    struct untyped_animation_data {
        std::unique_ptr<std::type_index> kind = nullptr;
        std::function<void(const std::chrono::milliseconds&)> ticker = nullptr;
        // ifdef protected
        std::vector<float> overlay_samples = {};
        std::array<float, 2> overlay_position = { 0.f, 0.f };
        //
    };

    struct animations_registry {
        registry animations = {};
        std::unordered_map<std::uintptr_t, registry_entity> possessed = {};
        std::unordered_map<std::uintptr_t, std::reference_wrapper<untyped_animation_data>> registered = {};

        template <typename value_t>
        typed_animation_data<value_t>& get_typed(animation<value_t>& animation_object);
    };

    inline animations_registry animations_context;

}
}
