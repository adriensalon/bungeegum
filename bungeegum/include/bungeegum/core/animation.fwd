#pragma once

#include <array>
#include <chrono>

#include <bungeegum/core/event.hpp>
#include <bungeegum/glue/curve.hpp>
#include <bungeegum/glue/simd.hpp>

namespace bungeegum {
namespace detail {

    template <typename value_t>
    struct animation_data {
        animation_data() = default;
        animation_data(const animation_data& other) = default;
        animation_data& operator=(const animation_data& other) = default;
        animation_data(animation_data&& other) = default;
        animation_data& operator=(animation_data&& other) = default;
        ~animation_data();

        std::uintptr_t raw_animation = 0;
        std::unique_ptr<value_t> min_value = nullptr;
        std::unique_ptr<value_t> max_value = nullptr;
        event_data<value_t> event;
        curve eval_curve = { 0.f, 1.f, std::vector<float2> {}, false };
        float1 duration_seconds = 0.f;
        bool1 is_playing = false;
        float1 playing_cursor_seconds = 0.f;
    };

    struct animation_update_data {
        std::unique_ptr<std::type_index> kind = nullptr;
        std::function<void(const std::chrono::milliseconds&)> ticker = nullptr;
        // ifdef protected for overlay
        std::vector<float1> overlay_samples = {};
        std::array<float1, 2> overlay_position = { 0.f, 0.f };
        //
    };

    struct animation_container_data {
        void notify_erase(const std::uintptr_t& raw_event);
        void tick(const std::chrono::milliseconds& delta_time);

        indexed_map<std::uintptr_t, animation_update_data> tickables = {};

    private:
        std::vector<std::uintptr_t> _tickables_to_erase = {};
    };

    inline animation_container_data global_animation_container;
}
}
