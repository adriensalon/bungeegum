#pragma once

#include <bungeegum/context/draw.hpp>
#include <bungeegum/context/interact.hpp>
#include <bungeegum/context/resolve.hpp>
#include <bungeegum/core/widget.hpp>
#include <bungeegum/glue/detection.fwd>
#include <bungeegum/glue/simd.hpp>

namespace bungeegum {

struct access {

    // draw

    template <typename widget_t>
    using draw_function = decltype(std::declval<widget_t>().draw(std::declval<draw_command&>()));

    template <typename widget_t>
    constexpr static bool has_draw_function = detail::is_detected_exact_v<void, draw_function, widget_t>;

    template <typename widget_t>
    constexpr static void detect_on_draw(widget_t& widget)
    {
        if constexpr (has_draw_function<widget_t>) {
            detail::untyped_widget_data& _widget_data = detail::get_untyped_widget(widget);
            _widget_data.drawer_command = draw_command();
            _widget_data.drawer = [&widget](draw_command& command) {
                widget.draw(command);
            };
        }
    }

    // interact

    template <typename widget_t>
    using interact_function = decltype(std::declval<widget_t>().interact(std::declval<interact_command&>()));

    template <typename widget_t>
    constexpr static bool has_interact_function = detail::is_detected_exact_v<void, interact_function, widget_t>;

    template <typename widget_t>
    constexpr static void detect_on_interact(widget_t& widget)
    {
        if constexpr (has_interact_function<widget_t>) {
            detail::untyped_widget_data& _widget_data = detail::get_untyped_widget(widget);
            _widget_data.interactor_command = interact_command();
            _widget_data.interactor = [&widget](interact_command& command) {
                widget.interact(command);
            };
        }
    }

    // resolve

    template <typename widget_t>
    using resolve_function = decltype(std::declval<widget_t>().resolve(std::declval<resolve_command&>()));

    template <typename widget_t>
    constexpr static bool has_resolve_function = detail::is_detected_exact_v<void, resolve_function, widget_t>;

    template <typename widget_t>
    constexpr static void detect_on_resolve(widget_t& widget)
    {
        detail::untyped_widget_data& _widget_data = detail::get_untyped_widget(widget);
        _widget_data.resolver_command = resolve_command();
        if constexpr (has_resolve_function<widget_t>) {
            _widget_data.resolver = [&widget](resolve_command& command) {
                widget.resolve(command);
            };
        } else {
            _widget_data.resolver = [&widget, &_widget_data](resolve_command& command) {
                if (_widget_data.children.empty()) {
                    command.resize(command.max_size());
                } else {
                    float2 _max_size = zero<float2>;
                    for (detail::untyped_widget_data& _child_widget_data : _widget_data.children) {
                        runtime_widget _child = detail::widgets_context.create_adopted(_child_widget_data);
                        float2 _child_size = command.resolve_child(_child, command.min_size(), command.max_size());
                        _max_size = glm::max(_max_size, _child_size);
                        command.position_child(_child, zero<float2>);
                    }
                    command.resize(_max_size);
                }
            };
        }
    }
};
}