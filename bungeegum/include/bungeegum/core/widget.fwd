#pragma once

#include <chrono>
#include <functional>
#include <memory>
#include <optional>
#include <typeindex>

#include <bungeegum/advanced/draw.hpp>
#include <bungeegum/advanced/interact.hpp>
#include <bungeegum/advanced/resolve.hpp>
#include <bungeegum/glue/detection.fwd>
#include <bungeegum/glue/registry.fwd>

namespace bungeegum {
namespace detail {

    struct untyped_widget_data {
        using untyped_widget_data_reference = std::reference_wrapper<untyped_widget_data>;

        std::unique_ptr<std::type_index> kind = nullptr;
        std::optional<untyped_widget_data_reference> parent = std::nullopt;
        std::vector<untyped_widget_data_reference> children = {};
        std::function<void(draw_command&)> drawer = nullptr;
        std::function<void(interact_command&)> interactor = nullptr;
        std::function<void(resolve_command&)> resolver = nullptr;
        std::optional<draw_command> drawer_command = std::nullopt;
        std::optional<interact_command> interactor_command = std::nullopt;
        std::optional<resolve_command> resolver_command = std::nullopt;

        // TO DELETE
        std::function<float2(resolve_command_data&)> widget_resolver = nullptr; // todo
        std::optional<resolve_command_data> widget_resolver_data = std::nullopt; // todo
    };

    struct widgets_registry {
        using untyped_widget_data_reference = std::reference_wrapper<untyped_widget_data>;
        using untyped_widget_data_must_do = std::pair<untyped_widget_data_reference, bool>;

        registry widgets = {};
        std::unordered_map<void*, entity_t> possessed = {};
        std::unordered_map<void*, untyped_widget_data_reference> accessors = {};
        std::optional<untyped_widget_data_reference> root = std::nullopt;
        std::vector<untyped_widget_data_must_do> drawables = {};
        std::vector<untyped_widget_data_must_do> interactables = {};
        std::vector<untyped_widget_data_must_do> resolvables = {};

        // TO DELETE
        // TO DELETE
        // TO DELETE
        // TO DELETE
        // TO DELETE
        // TO DELETE
        // TO DELETE
        // TO DELETE
        // TO DELETE
        // void clear_resolve();
        // void clear_draw();
        // bool is_parent(const untyped_widget_data& parent, const untyped_widget_data& child);
        void iterate_must_resolve(const std::function<void(untyped_widget_data&, const bool)>& iterate_callback);
        void iterate_must_draw(const std::function<void(untyped_widget_data&, const bool)>& iterate_callback);
        bool is_must_draw_empty() const;
        void iterate(const std::function<void(untyped_widget_data&)>& iterate_callback);

        template <typename widget_t>
        void build_root(widget_t& widget);

        // template <typename widget_t>
        // void on_resolve(widget_t* widget, const std::function<float2(resolve_command_data&)>& resolver);

        // template <typename widget_t>
        // void on_draw(widget_t* widget, const std::function<void(const float2, draw_command_data&)>& drawer);

        // template <typename widget_t>
        // void must_resolve(widget_t& widget, const bool must_resolve_children = true);

        // template <typename widget_t>
        // void must_draw(widget_t& widget, const bool must_draw_children = true);

        template <typename widget_t>
        untyped_widget_data& get(widget_t& widget);

        // template <typename widget_t>
        // widget_t& get(untyped_widget_data& data);

        // template <typename widget_t>
        // void iterate(const std::function<void(widget_t&)>& iterate_callback);

        // template <typename... values_t, typename widget_t>
        // void detach(typed_event_data<values_t...>& event, widget_t& widget);

        // template <typename value_t, typename widget_t>
        // void detach(typed_animation_data<value_t>& animation, widget_t& widget);
    };

    inline widgets_registry widgets_context;
}
}
