#pragma once

#include <functional>
#include <optional>
#include <typeindex>

#include <bungeegum/core/draw.hpp>
#include <bungeegum/core/interact.hpp>
#include <bungeegum/core/resolve.hpp>
#include <bungeegum/glue/raw.hpp>
#include <bungeegum/glue/registry.hpp>
#include <bungeegum/glue/reload.hpp>


namespace bungeegum {

struct runtime_widget;

namespace detail {

    struct untyped_widget_data {
        std::uintptr_t raw_widget = 0u;
        std::unique_ptr<std::type_index> kind = nullptr;
        std::string kind_debug = "";
        std::optional<std::reference_wrapper<untyped_widget_data>> parent = std::nullopt;
        std::vector<std::reference_wrapper<untyped_widget_data>> children = {};
        std::function<void(interact_command&)> interactor = nullptr;
        std::function<void(resolve_command&)> resolver = nullptr;
        std::function<void(draw_command&)> drawer = nullptr;
        std::optional<interact_command> interactor_command = std::nullopt;
        std::optional<resolve_command> resolver_command = std::nullopt;
        std::optional<draw_command> drawer_command = std::nullopt;

        //
        std::function<void(reloaded_loader&)> loader = nullptr;
        std::function<void(reloaded_saver&)> saver = nullptr;
        //

        inline bool operator==(const untyped_widget_data& other)
        {
            return raw_widget == other.raw_widget;
        }
    };

    struct widgets_registry {
        registry<registry_entity> widgets = {};
        std::unordered_map<std::uintptr_t, registry_entity> possessed = {};
        std::unordered_map<std::uintptr_t, std::reference_wrapper<untyped_widget_data>> registered = {};
        std::optional<std::reference_wrapper<untyped_widget_data>> root = std::nullopt;
        std::vector<std::reference_wrapper<untyped_widget_data>> resolvables = {};
        std::vector<std::reference_wrapper<untyped_widget_data>> drawables = {};

        // template <typename widget_t>
        // reference_widget<widget_t> get_reference_widget(detail::reloaded<widget_t>&& reloaded)

        runtime_widget get_runtime_widget(untyped_widget_data& widget_data);

        untyped_widget_data& get_widget_data(const runtime_widget& widget);

        // only use by context go context maybe
        void traverse_untyped(untyped_widget_data& iterate_root, const std::function<bool(untyped_widget_data&)>& iterate_callback);

        inline void save_widgets(const std::filesystem::path& archive_path)
        {
            reloaded_saver _archiver(archive_path);
            traverse_untyped(root.value().get(), [this, &_archiver](untyped_widget_data& _widget_data) {
                if (_widget_data.saver) {
                    _widget_data.saver(_archiver);
                }
                return true;
            });
        }

        inline void load_widgets(const std::filesystem::path& archive_path)
        {
            reloaded_loader _archiver(archive_path);
            traverse_untyped(root.value().get(), [this, &_archiver](untyped_widget_data& _widget_data) {
                if (_widget_data.loader) {
                    _widget_data.loader(_archiver);
                }
                return true;
            });
        }

        // load_widgets
    };

    inline widgets_registry widgets_context;
}
}
