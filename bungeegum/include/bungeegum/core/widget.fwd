#pragma once

#include <chrono>
#include <functional>
#include <memory>
#include <optional>
#include <typeindex>

#include <bungeegum/advanced/draw.hpp>
#include <bungeegum/advanced/interact.hpp>
#include <bungeegum/advanced/resolve.hpp>
#include <bungeegum/glue/detection.fwd>
#include <bungeegum/glue/registry.fwd>

namespace bungeegum {
namespace detail {

    struct untyped_widget_data {
        using untyped_widget_data_reference = std::reference_wrapper<untyped_widget_data>;

        std::unique_ptr<std::type_index> kind = nullptr;
        std::optional<untyped_widget_data_reference> parent = std::nullopt;
        std::vector<untyped_widget_data_reference> children = {};
        std::function<void(draw_command&)> drawer = nullptr;
        std::function<void(interact_command&)> interactor = nullptr;
        std::function<void(resolve_command&)> resolver = nullptr;
        std::optional<draw_command> drawer_command = std::nullopt;
        std::optional<interact_command> interactor_command = std::nullopt;
        std::optional<resolve_command> resolver_command = std::nullopt;

        // TO DELETE
        std::function<float2(resolve_command_data&)> widget_resolver = nullptr; // todo
        std::optional<resolve_command_data> widget_resolver_data = std::nullopt; // todo
    };

    struct widgets_registry {
        using untyped_widget_data_reference = std::reference_wrapper<untyped_widget_data>;
        using untyped_widget_data_callback = std::function<bool(untyped_widget_data&)>;

        registry widgets = {};
        std::unordered_map<void*, entity_t> possessed = {};
        std::unordered_map<void*, untyped_widget_data_reference> accessors = {};
        std::optional<untyped_widget_data_reference> root = std::nullopt;
        std::vector<untyped_widget_data_reference> drawables = {};
        std::vector<untyped_widget_data_reference> interactables = {};
        std::vector<untyped_widget_data_reference> resolvables = {};

        // bof ! pas ici peut etre jsp
        void traverse(untyped_widget_data& iterate_root, const untyped_widget_data_callback& iterate_callback);

        template <typename widget_t>
        untyped_widget_data& get(widget_t& widget);
    };

    inline widgets_registry widgets_context;
}
}
