#pragma once

#include <functional>
#include <optional>
#include <typeindex>

#include <bungeegum/context/draw.hpp>
#include <bungeegum/context/interact.hpp>
#include <bungeegum/context/resolve.hpp>
#include <bungeegum/glue/detection.fwd>
#include <bungeegum/glue/registry.fwd>

namespace bungeegum {
namespace detail {

    struct untyped_widget_data {
        std::unique_ptr<std::type_index> kind = nullptr;
        std::optional<std::reference_wrapper<untyped_widget_data>> parent = std::nullopt;
        std::vector<std::reference_wrapper<untyped_widget_data>> children = {};
        std::function<void(interact_command&)> interactor = nullptr;
        std::function<void(resolve_command&)> resolver = nullptr;
        std::function<void(draw_command&)> drawer = nullptr;
        std::optional<interact_command> interactor_command = std::nullopt;
        std::optional<resolve_command> resolver_command = std::nullopt;
        std::optional<draw_command> drawer_command = std::nullopt;
    };

    struct widgets_registry {
        registry widgets = {};
        std::unordered_map<void*, entity_t> possessed = {};
        std::unordered_map<void*, std::reference_wrapper<untyped_widget_data>> accessors = {};
        std::optional<std::reference_wrapper<untyped_widget_data>> root = std::nullopt;
        std::vector<std::reference_wrapper<untyped_widget_data>> resolvables = {};
        std::vector<std::reference_wrapper<untyped_widget_data>> drawables = {};

        void traverse_untyped(untyped_widget_data& iterate_root, const std::function<bool(untyped_widget_data&)>& iterate_callback);
    };

    inline widgets_registry widgets_context;
}
}
