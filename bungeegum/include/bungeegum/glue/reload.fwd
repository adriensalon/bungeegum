#pragma once

#include <cstddef>
#include <filesystem>

#define HSCPP_CXX_STANDARD 17
#include <hscpp/mem/Ref.h>
#include <hscpp/module/Tracker.h>

#include <bungeegum/glue/archive.fwd>
#include <bungeegum/glue/foreach.fwd>
#include <bungeegum/glue/simd.hpp>

namespace hscpp {
class Hotswapper;
namespace mem {
    class MemoryManager;
}
}

namespace bungeegum {
namespace detail {

#if !defined(BUNGEEGUM_ENABLE_HOTRELOAD)
#define BUNGEEGUM_ENABLE_HOTRELOAD 1 // TODO SET FROM CMAKE AND THIS TO 0
#endif

#if !BUNGEEGUM_ENABLE_HOTRELOAD

    template <typename widget_t>
    using reloaded = std::reference_wrapper<widget_t>;

#else

#define HOTRELOAD_CLASS(class, name) HSCPP_TRACK(class, name)
#define HOTRELOAD_METHOD hscpp_virtual
#define HOTRELOAD_FIELDS(...)                                                                            \
    template <typename value_t>                                                                          \
    friend struct bungeegum::detail::wrapper;                                                            \
    friend struct bungeegum::detail::input_archiver;                                                     \
    friend struct bungeegum::detail::output_archiver;                                                    \
    friend class cereal::access;                                                                         \
    template <typename archive_t, typename... fields_t>                                                  \
    void _bungeegum_serialize_fields(archive_t& archive, const std::string& names, fields_t&&... fields) \
    {                                                                                                    \
        std::vector<std::string> _names;                                                                 \
        std::stringstream _sstream(names);                                                               \
        while (_sstream.good()) {                                                                        \
            std::string _substr;                                                                         \
            std::getline(_sstream, _substr, ',');                                                        \
            if (_substr[0] == ' ') {                                                                     \
                _substr = _substr.substr(1, _substr.length() - 1);                                       \
            }                                                                                            \
            _names.push_back(_substr);                                                                   \
        }                                                                                                \
        std::tuple<fields_t&...> _tuple((fields)...);                                                    \
        constexpr size_t _count = std::variant_size_v<std::variant<fields_t...>>;                        \
        bungeegum::detail::constexpr_for<0, _count, 1>([&](auto _index) {                                \
            using field_type_t = std::variant_alternative_t<_index, std::variant<fields_t...>>;          \
            field_type_t& _field = std::get<_index>(_tuple);                                             \
            try {                                                                                        \
                archive(cereal::make_nvp(_names[_index].c_str(), _field));                               \
            } catch (...) {                                                                              \
                std::cout << "error detected :) \n";                                                     \
            }                                                                                            \
        });                                                                                              \
    }                                                                                                    \
    hscpp_virtual void _bungeegum_load(cereal::JSONInputArchive& archive)                                \
    {                                                                                                    \
        _bungeegum_serialize_fields<cereal::JSONInputArchive>(archive, { #__VA_ARGS__ }, __VA_ARGS__);   \
    }                                                                                                    \
    hscpp_virtual void _bungeegum_save(cereal::JSONOutputArchive& archive)                               \
    {                                                                                                    \
        _bungeegum_serialize_fields<cereal::JSONOutputArchive>(archive, { #__VA_ARGS__ }, __VA_ARGS__);  \
    }

    template <typename widget_t>
    struct reloaded {
        reloaded() = delete;
        reloaded(const reloaded& other);
        reloaded& operator=(const reloaded& other);
        reloaded(reloaded&& other);
        reloaded& operator=(reloaded&& other);

        widget_t& get();
        const widget_t& get() const;

    private:
        hscpp::mem::UniqueRef<widget_t> _ref;
        reloaded(hscpp::mem::UniqueRef<widget_t>&& ref);
        friend struct reloader;
    };

    /// @brief Current state of the hotswapping.
    enum struct reload_state {
        idle,
        compiling,
        started_compiling,
        performed_swap,
        failed_swap,
    };

    /// @brief Instances of this struct allocate memory that can be hotswapped. They trigger
    /// compilation and manage the files and directories to provide to the compiler.
    /// @details Instances of this struct can only be moved.
    struct reloader {
        reloader();
        reloader(const reloader& other) = delete;
        reloader& operator=(const reloader& other) = delete;
        reloader(reloader&& other) = default;
        reloader& operator=(reloader&& other) = default;

        /// @brief Allocates a new object that can be hotswapped, taking no argument.
        /// @exception Throws a compile-time exception if the widget type is not default-
        /// constructible.
        template <typename widget_t>
        reloaded<widget_t> allocate();

        /// @brief Gets the amount of memory blocks currently allocated.
        std::size_t allocated_blocks_count();

        /// @brief Emplaces an include directory for recompilation.
        void add_include_directory(const std::filesystem::path& directory);

        /// @brief Emplaces a static library for recompilation.
        void add_library(const std::filesystem::path& file);

        /// @brief Emplaces a source directory for recompilation.
        void add_source_directory(const std::filesystem::path& directory);

        /// @brief Emplaces a source file that will be recompiled each time.
        void add_force_compiled_source_file(const std::filesystem::path& file);

        /// @brief Clears all files and directories provided for recompilation.
        void clear();

        /// @brief Forces an update, blocking the thread until recompilation has finished.
        void force_update();

        /// @brief Asynchronously waits for changes in the provided files and folders, triggers
        /// recompilation when needed and hotswaps allocated objects.
        reload_state update();

    private:
        std::shared_ptr<hscpp::Hotswapper> _swapper = nullptr;
        std::shared_ptr<hscpp::mem::UniqueRef<hscpp::mem::MemoryManager>> _manager = nullptr;
    };

#endif
}
}

#include <bungeegum/glue/reload.inl>