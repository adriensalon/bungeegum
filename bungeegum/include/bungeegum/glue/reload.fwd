#pragma once

#include <filesystem>

#define HSCPP_CXX_STANDARD 17

#include <hscpp/mem/Ref.h>
#include <hscpp/module/Tracker.h>

#include <bungeegum/glue/archive.fwd>
#include <bungeegum/glue/simd.hpp>

//
//
#define BUNGEEGUM_ENBALE_HOTRELOAD 1
//
//

namespace hscpp {
class Hotswapper;
namespace mem {
    class MemoryManager;
}
}

namespace bungeegum {
namespace detail {

#if !defined(BUNGEEGUM_ENBALE_HOTRELOAD)
#define BUNGEEGUM_ENBALE_HOTRELOAD 0
#endif

#if BUNGEEGUM_ENBALE_HOTRELOAD

#define HOTRELOAD_CLASS(class, name) HSCPP_TRACK(class, name)
#define HOTRELOAD_METHOD hscpp_virtual
#define HOTRELOAD_FIELDS(...)          \
    template <typename archive_t>      \
    void serialize(archive_t& archive) \
    {                                  \
        archive(__VA_ARGS__);          \
    }                                  \
    friend class cereal::access;

    template <typename widget_t>
    struct reloaded;

    struct reloader {
        reloader();
        reloader(const reloader& other) = delete;
        reloader& operator=(const reloader& other) = delete;
        reloader(reloader&& other) = default;
        reloader& operator=(reloader&& other) = default;

        template <typename widget_t>
        reloaded<widget_t> allocate();

        uint1 allocated_blocks_count();
        void add_include_directory(const std::filesystem::path& directory);
        void add_library(const std::filesystem::path& file);
        void add_source_directory(const std::filesystem::path& directory);
        void add_force_compiled_source_file(const std::filesystem::path& file);
        void force_update();
        void update();

    private:
        std::shared_ptr<hscpp::Hotswapper> _swapper = nullptr;
        std::shared_ptr<hscpp::mem::UniqueRef<hscpp::mem::MemoryManager>> _manager = nullptr;
    };

    template <typename widget_t>
    struct reloaded {
        reloaded() = default;
        reloaded(const reloaded& other) = delete;
        reloaded& operator=(const reloaded& other) = delete;
        reloaded(reloaded&& other);
        reloaded& operator=(reloaded&& other);

        widget_t& get();
        const widget_t& get() const;

    private:
        hscpp::mem::UniqueRef<widget_t> _ref;
        reloaded(hscpp::mem::UniqueRef<widget_t>&& ref);
        friend struct reloader;
    };

#else

    template <typename widget_t>
    using reloaded = widget_t&;

#endif
}
}

#include <bungeegum/glue/reload.inl>