#pragma once

#include <memory>

#include <bungeegum/core/config.hpp>
#include <bungeegum/core/math.hpp>
#include <bungeegum/glue/window.fwd>

namespace Diligent {
struct SwapChainDesc;
}

namespace bungeegum {
namespace detail {

    /// @brief Instances of this struct represent cross-platform GPU renderers that will select the
    /// most appropriate graphics API depending on the platform. Macros defined above can be
    /// modified to force usage of a specific platform.
    /// @details Instances of this struct can only be moved.
    struct renderer {
        renderer() = default;
        renderer(const renderer& other) = delete;
        renderer& operator=(const renderer& other) = delete;
        renderer(renderer&& other) = default;
        renderer& operator=(renderer&& other) = default;

#if (TOOLCHAIN_PLATFORM_WIN32 || TOOLCHAIN_PLATFORM_UWP)
        /// @brief Creates an instance from an existing DirectX 11 context.
        void attach_directx11(window& existing_window, void* directx_context, void* directx_swapchain);

        /// @brief Creates an instance from an existing DirectX 12 context.
        void attach_directx12(window& existing_window, void* directx_context, void* directx_swapchain);
#endif

        /// @brief Creates an instance from an existing OpenGL context.
        void attach_opengl(window& existing_window);

#if (TOOLCHAIN_PLATFORM_WIN32 || TOOLCHAIN_PLATFORM_LINUX || TOOLCHAIN_PLATFORM_ANDROID)
        /// @brief Creates an instance from an existing window with the Vulkan API.
        void attach_vulkan(window& existing_window);
#endif

#if (TOOLCHAIN_PLATFORM_WIN32 || TOOLCHAIN_PLATFORM_UWP)
        /// @brief Creates an instance from an existing window with the DirectX 11 API.
        void create_directx11(window& existing_window);

        /// @brief Creates an instance from an existing window with the DirectX 12 API.
        void create_directx12(window& existing_window);
#endif

        /// @brief Creates an instance from an existing window with the OpenGL API.
        void create_opengl(window& existing_window);

#if (TOOLCHAIN_PLATFORM_WIN32 || TOOLCHAIN_PLATFORM_LINUX || TOOLCHAIN_PLATFORM_ANDROID)
        /// @brief Creates an instance from an existing window with the Vulkan API.
        void create_vulkan(window& existing_window);
#endif

		/// @brief 
		/// @return 
		[[nodiscard]] bool has_renderer() const;

        /// @brief Begins a new frame, enabling all drawing commands.
        /// @exception Throws a backtraced exception if a new frame has already begun.
        void new_frame();
		
#if TOOLCHAIN_PLATFORM_EMSCRIPTEN
		void consume_emscripten_mouse_events(std::vector<emscripten_mouse_event>& events);

		void consume_emscripten_wheel_events(std::vector<emscripten_wheel_event>& events);

		void consume_emscripten_key_events(std::vector<emscripten_key_event>& events);
#else		
		void consume_sdl_events(std::vector<SDL_Event>& events);
#endif

        /// @brief Ends the frame, disabling all drawing commands. Swaps the window buffers.
        /// @exception Throws a backtraced exception if the frame has already been ended.
        void present();

        /// @brief Rebuilds the ImGui fonts.
        void rebuild_fonts();

		void resize(const float2 display_size);

        /// @brief The color to use when clearing the screen.
        float4 clear_color = { 0.f, 0.f, 0.f, 1.f };

    private:
        struct renderer_data;

        void _consolidate(const Diligent::SwapChainDesc& swapchain_descriptor);

        bool _is_rendering = false;
        float4x4 _mvp_matrix = {}; // go identity
        std::shared_ptr<renderer_data> _data = nullptr;
    };
}
}