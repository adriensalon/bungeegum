#pragma once

#include <tinysplinecxx.h> // replace by custom impl

#include <array>
#include <cstddef>
#include <chrono>
#include <memory>
#include <vector>

#include <bungeegum/core/math.hpp>
#include <bungeegum/core/event.fwd>

namespace bungeegum {

enum struct animation_mode;

namespace detail {

	using curve_data = tinyspline::BSpline;

    template <typename value_t>
    struct animation_data {
        animation_data() = default;
        animation_data(const animation_data& other) = default;
        animation_data& operator=(const animation_data& other) = default;
        animation_data(animation_data&& other) = default;
        animation_data& operator=(animation_data&& other) = default;
        ~animation_data();

        std::uintptr_t raw = 0;
        std::unique_ptr<value_t> min_value = nullptr;
        std::unique_ptr<value_t> max_value = nullptr;
        event_data<value_t> on_value_changed_event;
        event_data<> on_end_event;
        curve_data bspline = {};
        float duration_seconds = 0.f;
        bool is_playing = false;
        float playing_cursor_seconds = 0.f;
		animation_mode mode = {};
    };

    struct animation_update_data {
        std::unique_ptr<std::type_index> kind = nullptr;
        std::function<void(const std::chrono::milliseconds&)> ticker = nullptr;

#if BUNGEEGUM_USE_OVERLAY
        std::string clean_typename = {};
        std::vector<float> overlay_samples = {};
        std::array<float, 2> overlay_position = { 0.f, 0.f };
#endif
    };

    struct animations_manager {
        animations_manager() = default;
        animations_manager(const animations_manager& other) = delete;
        animations_manager& operator=(const animations_manager& other) = delete;
        animations_manager(animations_manager&& other) = delete;
        animations_manager& operator=(animations_manager&& other) = delete;

        using const_iterator = std::unordered_map<std::uintptr_t, animation_update_data>::const_iterator;

        [[nodiscard]] const_iterator begin() const;

        [[nodiscard]] bool contains(const std::uintptr_t raw_animation) const;

        [[nodiscard]] const_iterator end() const;

        void notify_erase(const std::uintptr_t raw_animation);

        [[nodiscard]] animation_update_data& operator[](const std::uintptr_t raw_animation);

        std::size_t size() const;

        void update(const std::chrono::milliseconds& delta_time);

    private:
        std::unordered_map<std::uintptr_t, animation_update_data> _updatables = {};
        std::vector<std::uintptr_t> _updatables_to_erase = {};
    };
}
}
