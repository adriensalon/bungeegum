#pragma once


#include <array>
#include <cstddef>
#include <chrono>
#include <memory>
#include <optional>
#include <vector>

#include <bungeegum/core/math.hpp>
#include <bungeegum/core/event.fwd>

namespace bungeegum {

enum struct animation_mode;

template <typename value_t>
struct animation;

namespace detail {

    struct animation_update_data {
        std::unique_ptr<std::type_index> kind = nullptr;
        std::function<void(const std::chrono::milliseconds&)> ticker = nullptr;
#if BUNGEEGUM_USE_OVERLAY
        std::string clean_typename = {};
        std::vector<float> overlay_samples = {};
        std::array<float, 2> overlay_position = { 0.f, 0.f };
#endif
    };

    template <typename value_t>
    struct animation_data {
        animation_data();
        animation_data(const animation_data& other);
        animation_data& operator=(const animation_data& other);
        animation_data(animation_data&& other);
        animation_data& operator=(animation_data&& other);
        ~animation_data();

        std::uintptr_t raw = 0u;
        std::optional<value_t> min_value = std::nullopt;
        std::optional<value_t> max_value = std::nullopt;
        event_data<value_t> on_value_changed_event = {};
        event_data<> on_end_event = {};
        curve_data bspline = {};
        float duration_seconds = 0.f;
        bool is_playing = false;
        float playing_cursor_seconds = 0.f;
		animation_mode mode = {};
        animation_update_data update_data = {};
    };

    struct animations_manager_data {
        animations_manager_data() = default;
        animations_manager_data(const animations_manager_data& other) = delete;
        animations_manager_data& operator=(const animations_manager_data& other) = delete;
        animations_manager_data(animations_manager_data&& other) = delete;
        animations_manager_data& operator=(animations_manager_data&& other) = delete;

        std::unordered_map<std::uintptr_t, std::reference_wrapper<animation_update_data>> updatables = {};
        std::vector<std::uintptr_t> updatables_to_erase = {};
    };
    
    template <typename value_t>
    struct animation_access {
        [[nodiscard]] static const animation_data<value_t>& get_data(const animation<value_t>& object);
    };
}
}
