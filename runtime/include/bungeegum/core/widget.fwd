#pragma once

#include <any>
#include <functional>
#include <optional>
#include <typeindex>
#include <variant>
#include <vector>

#include <bungeegum/core/math.hpp>
#include <bungeegum/glue/detection.hpp>
#include <bungeegum/glue/raw.hpp>
#include <bungeegum/glue/hotswap.hpp>
#include <bungeegum/glue/window.hpp>

struct ImDrawList;

namespace bungeegum {

struct draw_command;
struct resolve_command;
struct interact_command;
struct widget_id;

template <typename widget_t>
struct widget_ref;

namespace detail {
    namespace traits {

        template <typename widget_t>
        using detected_draw_function = decltype(std::declval<widget_t>().draw(std::declval<draw_command&>()));

        template <typename widget_t>
        using detected_interact_function = decltype(std::declval<widget_t>().interact(std::declval<interact_command&>()));

        template <typename widget_t>
        using detected_resolve_function = decltype(std::declval<widget_t>().resolve(std::declval<resolve_command&>()));

        template <typename widget_t>
        constexpr static bool has_draw_function_v = is_detected_exact_v<void, detected_draw_function, widget_t>;

        template <typename widget_t>
        constexpr static bool has_interact_function_v = is_detected_exact_v<void, detected_interact_function, widget_t>;

        template <typename widget_t>
        constexpr static bool has_resolve_function_v = is_detected_exact_v<void, detected_resolve_function, widget_t>;
    }

    struct widget_update_data {
        std::uintptr_t raw = {};
        std::any inplace_data = {};
        std::optional<std::reference_wrapper<widget_update_data>> parent = std::nullopt;
        std::vector<std::reference_wrapper<widget_update_data>> children = {};		
		float2 local_min_size = zero<float2>;
        float2 local_max_size = infinity<float2>;
		float3 local_position = zero<float3>;
		float3 local_rotation = zero<float3>;
		float2 resolved_size = zero<float2>;
		float4x4 resolved_transform = identity<float4x4>;
        std::function<void(resolve_command&)> resolver = nullptr;
        std::function<void(interact_command&)> interactor = nullptr;
        std::function<void(draw_command&)> drawer = nullptr;
#if BUNGEEGUM_USE_HOTSWAP
        std::function<void(swapped_load_guard&)> loader = nullptr;
        std::function<void(swapped_save_guard&)> saver = nullptr;
        std::function<std::uintptr_t()> true_ptr = nullptr;
        std::function<std::size_t()> true_sizeof = nullptr;
#endif
#if BUNGEEGUM_USE_OVERLAY
        std::string clean_typename = {};
#endif
    };

	using interact_command_data = std::reference_wrapper<std::variant<
            window_resized_event,
            mouse_moved_event,
            mouse_down_event,
            mouse_up_event,
            mouse_pressed_event>>;			

	using resolve_command_data = std::reference_wrapper<widget_update_data>;
	
	struct draw_command_data {
		std::uintptr_t raw_updatable;
		std::uintptr_t raw_pipeline;
		ImDrawList* draw_list = nullptr;
	};

    using widget_id_data = std::uintptr_t;

    template <typename widget_t>
    using widget_ref_data = reference_type_t<widget_t>;	
	
    struct widget_manager_data {
        widget_manager_data() = default;
        widget_manager_data(const widget_manager_data& other) = delete;
        widget_manager_data& operator=(const widget_manager_data& other) = delete;
        widget_manager_data(widget_manager_data&& other) = default;
        widget_manager_data& operator=(widget_manager_data&& other) = default;

        std::unordered_map<std::uintptr_t, widget_update_data> updatables = {};
        std::unordered_map<std::uintptr_t, std::reference_wrapper<widget_update_data>> resolvables = {};
        std::unordered_map<std::uintptr_t, std::reference_wrapper<widget_update_data>> interactables = {};
        std::unordered_map<std::uintptr_t, std::reference_wrapper<widget_update_data>> drawables = {};
#if BUNGEEGUM_USE_HOTSWAP
        std::unique_ptr<swapper_handle> hotswap_reloader = nullptr;
#endif
    };

    struct resolve_command_access {
        [[nodiscard]] static resolve_command make_from_data(const resolve_command_data& data);
        [[nodiscard]] static resolve_command_data& get_data(resolve_command& object);
    };

    struct draw_command_access {
        [[nodiscard]] static draw_command make_from_data(const draw_command_data& data);
        [[nodiscard]] static draw_command_data& get_data(draw_command& object);
    };

    struct interact_command_access {
        [[nodiscard]] static interact_command make_from_data(const interact_command_data& data);
        [[nodiscard]] static interact_command_data& get_data(interact_command& object);
    };

    struct widget_id_access {
        [[nodiscard]] static widget_id make_from_data(const widget_id_data& data);
        [[nodiscard]] static widget_id_data get_data(const widget_id& object);
    };

    template <typename widget_t>
    struct widget_ref_access {
        [[nodiscard]] static widget_ref<widget_t> make_from_data(const widget_ref_data<widget_t>& data);
        [[nodiscard]] static widget_ref_data<widget_t>& get_data(widget_ref<widget_t>& object);
        [[nodiscard]] static const widget_ref_data<widget_t>& get_data(const widget_ref<widget_t>& object);
    };
}
}
